
[GNU Make](https://www.gnu.org/software/make/) ist weit verbreitetes Build-Tool, mit dem sich der Build-Prozess automatisieren lässt.

# 1 `Makefile`文件 
Der Build-Prozess wird in der Shell mit dem Kommando `make` gestartet. Make erwartet im aktuellen Verzeichnis eine Datei namens `Makefile`, die den Build-Prozess für das Projekt als eine Menge von Regeln beschreibt. 

Eine Regel gibt an,
- von welchen Inputs eine zu bauende Zieldatei (_target_) abhängig ist und
- mit welchen Shell-Kommandos das _target_ aus diesen Inputs erzeugt wird.


# 2 Make 命令本身 
Make automatisiert das _inkrementelle Bauen_ eines Projekts: Anhand der Zeitstempel der Quell- und Zieldateien wird ermittelt, welche Quelldateien eines Projekts sich geändert haben. Nur die davon abhängigen Zieldateien werden neu gebaut. Gerade bei großen Projekten spart dies viel Zeit.


# 3 Ubung

1 生成Makefile文件本身
Als kleine Übung legen Sie im Editor ein Makefile zum Hello-World-Programm an:
Makefile 文件的内容
```
CFLAGS += -Wall -Wextra -Werror -std=gnu17 -O 

hello: hello.c
```

Die Variable CFLAGS enthält die zu verwendenden Compiler-Flags.
Das Target hello hängt von hello.c ab. Ein explizites Kommando zum Aufruf des C-Compilers ist hier nicht nötig, da Make eine entsprechende default-Regel enthält.


Jetzt testen Sie das Makefile:
```sh
$ rm -f hello
$ make  # hello fehlt und wird neu gebaut
gcc -Wall -Wextra -Werror -std=gnu17 -O    hello.c   -o hello
$ make  # keine Änderung, also gibt es nichts zu tun
make: 'hello' is up to date.
$ touch hello.c   # über Zeitstempel eine Quellcode-Änderung simulieren
$ make  # jetzt wird neu gebaut
gcc -Wall -Wextra -Werror -std=gnu17 -O    hello.c   -o hello
$
```



# 4 Makefile文件的格式
https://www.ruanyifeng.com/blog/2015/02/make.html


Makefile文件由一系列规则（rules）构成。每条规则的形式如下。

```

<target> : <prerequisites> 
[tab]  <commands>

```

上面第一行冒号前面的部分，叫做"目标"（target），冒号后面的部分叫做"前置条件"（prerequisites）；第二行必须由一个tab键起首，后面跟着"命令"（commands）。

"目标"是必需的，不可省略；"前置条件"和"命令"都是可选的，但是两者之中必须至少存在一个。

每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。

targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。
command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 Tab 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）
prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。



## 4.1 目标（target）

一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。


1 
除了文件名，目标还可以是某个操作的名字，这称为"伪目标"（phony target）。

> ```bash
> 
> clean:
>       rm *.o
> ```


上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于"伪目标 "，作用是删除对象文件。

> ```bash
> 
> $ make  clean
> ```


2 
但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。

为了避免这种情况，可以明确声明clean是"伪目标"，写法如下。

> ```bash
> 
> .PHONY: clean
> clean:
>         rm *.o temp
> ```

声明clean是"伪目标"之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看[手册](http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets)。


3 
如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。

> ```bash
> 
> $ make
> ```

上面代码执行Makefile文件的第一个目标。


## 4.2 例子 

Makefile 中的内容
![](images/Pasted%20image%2020241104231326.png)

![](images/Pasted%20image%2020241104231335.png)


执行 make hello , hello 是一个操作的名字, 在 makefile 中第一行定义的
在 makefile 中第一行定义中  hello.o 是 hello 的 prerequisites.  如果 文件夹中没有hello.o , 则 就会 执行 makefile 中第二行定义的, 去产生 hello.o

![](images/Pasted%20image%2020241104231347.png)

![](images/Pasted%20image%2020241104231353.png)


